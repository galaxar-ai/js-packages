{"version":3,"sources":["../lib/ServiceContainer.js"],"sourcesContent":["import ConfigLoader, { JsonConfigProvider } from '@galaxar/jsonc';\nimport { _, pushIntoBucket, eachAsync_, arrayToObject, esmCheck } from '@galaxar/utils';\nimport { fs, tryRequire as _tryRequire } from '@galaxar/sys';\nimport { InvalidConfiguration, Types } from '@galaxar/types';\nimport { TopoSort } from '@galaxar/algo';\n\nimport path from 'node:path';\n\nimport Feature from './Feature';\nimport defaultOpts from './defaultOpts';\nimport AsyncEmitter from './helpers/AsyncEmitter';\nimport { consoleLogger, makeLogger, setLogLevel } from './logger';\n\nconst FILE_EXT = ['.js', '.mjs', '.cjs', '.ts'];\n\nconst configOverrider = (defConf, envConf) => {\n    const { serviceGroup: defServiceGroup, ..._def } = defConf ?? {};\n    const { serviceGroup: envServiceGroup, ..._env } = envConf ?? {};\n\n    const serviceGroup = {};\n\n    if (defServiceGroup || envServiceGroup) {\n        defServiceGroup &&\n            _.each(defServiceGroup, (servicesMap, serviceName) => {\n                serviceGroup[serviceName] = servicesMap;\n            });\n\n        envServiceGroup &&\n            _.each(envServiceGroup, (servicesMap, serviceName) => {\n                serviceGroup[serviceName] = {\n                    ...serviceGroup[serviceName],\n                    ...servicesMap,\n                };\n            });\n    }\n\n    const ret = {\n        ..._def,\n        ..._env,\n    };\n\n    if (!_.isEmpty(serviceGroup)) {\n        ret.serviceGroup = serviceGroup;\n    }\n\n    return ret;\n};\n\n/**\n * Service container class.\n * @class\n */\nclass ServiceContainer extends AsyncEmitter {\n    logError = (error, message) => {\n        return this.logException('error', error, message);\n    };\n\n    logErrorAsWarning = (error, message) => {\n        return this.logException('warn', error, message);\n    };\n\n    /**\n     * @param {string} name - The name of the container instance.\n     * @param {object} [options] - Container options\n     * @property {string} [options.env] - Environment, default to process.env.NODE_ENV\n     * @property {string} [options.workingPath] - App's working path, default to process.cwd()\n     * @property {string} [options.configPath] - App's config path, default to \"conf\" under workingPath\n     * @property {string} [options.configName] - App's config basename, default to \"app\"\n     * @property {string} [options.disableEnvAwareConfig=false] - Don't use environment-aware config\n     * @property {array} [options.allowedFeatures] - A list of enabled feature names\n     * @property {boolean} [options.loadConfigFromOptions=false] - Whether to load config from passed-in options\n     * @property {object} [options.config] - Config in options, used only when loadConfigFromOptions\n     */\n    constructor(name, options) {\n        super();\n\n        /**\n         * Name of the app\n         * @member {object}\n         **/\n        this.name = name;\n\n        /**\n         * App options\n         * @member {object}\n         */\n        this.options = {\n            ...defaultOpts,\n            ...options,\n        };\n\n        /**\n         * Environment flag\n         * @member {string}\n         */\n        this.env = this.options.env;\n\n        /**\n         * Working directory of this cli app\n         * @member {string}\n         */\n        this.workingPath = this.options.workingPath ? path.resolve(this.options.workingPath) : process.cwd();\n\n        /**\n         * Config path\n         * @member {string}\n         */\n        this.configPath = this.toAbsolutePath(this.options.configPath);\n\n        /**\n         * Feature path\n         */\n        this.featuresPath = this.toAbsolutePath(this.options.featuresPath);\n\n        this._logCache = [];\n\n        // dummy\n        this.log = (...args) => {\n            this._logCache.push(args);\n            return this;\n        };\n    }\n\n    /**\n     * Start the container.\n     * @fires ServiceContainer#configLoaded\n     * @fires ServiceContainer#ready\n     * @returns {Promise.<ServiceContainer>}\n     */\n    async start_() {\n        this.log('verbose', `Starting app [${this.name}] ...`);\n\n        await this.emit_('starting', this);\n\n        this._featureRegistry = {\n            //firstly look up \"features\" under current working path, and then try the builtin features path\n            '*': this._getFeatureFallbackPath(),\n        };\n\n        /**\n         * Loaded features, name => feature object\n         * @member {object}\n         */\n        this.features = {};\n\n        /**\n         * Loaded services\n         * @member {object}\n         */\n        this.services = {};\n\n        if (this.options.loadConfigFromOptions) {\n            this.config = this.options.config;\n        } else {\n            /**\n             * Configuration loader instance\n             * @member {ConfigLoader}\n             */\n            this.configLoader = this.options.disableEnvAwareConfig\n                ? new ConfigLoader(\n                      new JsonConfigProvider(path.join(this.configPath, this.options.configName + '.json')),\n                      this\n                  )\n                : ConfigLoader.createEnvAwareJsonLoader(\n                      this.configPath,\n                      this.options.configName,\n                      this.env,\n                      this,\n                      configOverrider\n                  );\n\n            await this.loadConfig_();\n        }\n\n        /**\n         * Config loaded event.\n         * @event ServiceContainer#configLoaded\n         */\n        await this.emit_('configLoaded', this.config);\n\n        if (!_.isEmpty(this.config)) {\n            await this._loadFeatures_();\n        } else {\n            this.log('verbose', `Empty configuration! Config path: ${this.configPath}`);\n        }\n\n        /**\n         * App ready\n         * @event ServiceContainer#ready\n         */\n        await this.emit_('ready', this);\n\n        /**\n         * Flag showing the app is started or not.\n         * @member {bool}\n         */\n        this.started = true;\n\n        return this;\n    }\n\n    /**\n     * Stop the container\n     * @fires ServiceContainer#stopping\n     * @returns {Promise.<ServiceContainer>}\n     */\n    async stop_() {\n        /**\n         * App stopping\n         * @event ServiceContainer#stopping\n         */\n        await this.emit_('stopping', this);\n\n        this.log('verbose', `Stopping app [${this.name}] ...`);\n\n        this.started = false;\n\n        delete this.services;\n        delete this.features;\n        delete this._featureRegistry;\n\n        delete this.config;\n        delete this.configLoader;\n\n        await this.emit_('stopped', this);\n\n        this.allOff();\n    }\n\n    /**\n     * @returns {ServiceContainer}\n     */\n    async loadConfig_() {\n        let configVariables = this._getConfigVariables();\n\n        /**\n         * App configuration\n         * @member {object}\n         */\n        this.config = await this.configLoader.load_(configVariables);\n\n        return this;\n    }\n\n    /**\n     * Translate a relative path of this app module to an absolute path\n     * @param {array} args - Array of path parts\n     * @returns {string}\n     */\n    toAbsolutePath(...args) {\n        if (args.length === 0 || args[0] == null) {\n            return this.workingPath;\n        }\n\n        return path.resolve(this.workingPath, ...args);\n    }\n\n    tryRequire(pkgName, local) {\n        const obj = local ? require(pkgName) : _tryRequire(pkgName, this.workingPath);\n        return esmCheck(obj);\n    }\n\n    /**\n     * Register a service\n     * @param {string} name\n     * @param {object} serviceObject\n     * @param {boolean} override\n     */\n    registerService(name, serviceObject, override) {\n        if (name in this.services && !override) {\n            throw new Error('Service \"' + name + '\" already registered!');\n        }\n\n        this.services[name] = serviceObject;\n        this.log('verbose', `Service \"${name}\" registered.`);\n        return this;\n    }\n\n    /**\n     * Check whether a service exists\n     * @param {*} name\n     * @returns {boolean}\n     */\n    hasService(name) {\n        return name in this.services;\n    }\n\n    /**\n     * Get a service from module hierarchy\n     * @param name\n     * @returns {object}\n     */\n    getService(name) {\n        return this.services[name];\n    }\n\n    /**\n     * Check whether a feature is enabled in the app.\n     * @param {string} feature\n     * @returns {bool}\n     */\n    enabled(feature) {\n        return this.features[feature]?.enabled ?? false;\n    }\n\n    /**\n     * Add more or overide current feature registry\n     * @param {object} registry\n     */\n    addFeatureRegistry(registry) {\n        // * is used as the fallback location to find a feature\n        if (registry.hasOwnProperty('*')) {\n            pushIntoBucket(this._featureRegistry, '*', registry['*']);\n        }\n\n        Object.assign(this._featureRegistry, _.omit(registry, ['*']));\n    }\n\n    /**\n     * Helper method to log an exception\n     * @param {*} level\n     * @param {*} error\n     * @param {*} summary\n     * @returns {ServiceContainer}\n     */\n    logException(level, error, summary) {\n        this.log(\n            level,\n            (summary ? summary + '\\n' : '') + error.message,\n            _.pick(error, ['name', 'status', 'code', 'info', 'stack', 'request'])\n        );\n        return this;\n    }\n\n    featureConfig(config, typeInfo, name) {\n        return this.sanitize(config, typeInfo, name);\n    }\n\n    sanitize(config, typeInfo, name, category) {\n        try {\n            return Types.sanitize(config, { type: 'object', ...typeInfo }, undefined, name);\n        } catch (err) {\n            throw new InvalidConfiguration(err.message, this, category ? `${category}::${name}` : name);\n        }\n    }\n\n    _getConfigVariables() {\n        const processInfo = {\n            env: process.env,\n            arch: process.arch, // The operating system CPU architectureï¼Œ 'arm', 'arm64','x64', ...\n            argv: process.argv,\n            cwd: process.cwd(),\n            pid: process.pid,\n            platform: process.platform,\n        };\n\n        return {\n            app: this,\n            env: this.env,\n            process: processInfo,\n        };\n    }\n\n    _getFeatureFallbackPath() {\n        return [path.resolve(__dirname, 'features'), this.featuresPath];\n    }\n\n    _sortFeatures(features) {\n        if (features.length === 0) {\n            return features;\n        }\n\n        const topoSort = new TopoSort();\n        features.forEach(([feature]) => {\n            topoSort.depends(feature.name, feature.depends);\n        });        \n\n        const groups = arrayToObject(features, ([feature]) => feature.name);\n        const keys = topoSort.sort();\n\n        const sorted = [];\n        keys.forEach((key) => {\n            const feature = groups[key];\n            if (feature) {\n                sorted.push(feature);\n            } else {\n                if (!this.features[key]?.enabled) {\n                    throw new InvalidConfiguration(`A prerequisite feature \"${key}\" is not enabled.`, this);\n                }\n            }\n        });\n\n        return sorted;\n    }\n\n    flushLogCache() {\n        if (this.runnable && this.config.logger == null) {\n            setLogLevel(this.options.logLevel);\n            const logging = makeLogger(consoleLogger);\n            this.logger = { log: logging };\n            this.log = logging;\n            this._logCache.forEach((log) => this.logger.log(...log));\n            this._logCache.length = 0;\n        }\n    }\n\n    /**\n     * Load features\n     * @private\n     * @returns {bool}\n     */\n    async _loadFeatures_() {\n        // run config stage separately first\n        let configStageFeatures = [];\n\n        // load features\n        _.each(this.config, (featureOptions, name) => {\n            if (this.options.allowedFeatures && this.options.allowedFeatures.indexOf(name) === -1) {\n                //skip disabled features\n                return;\n            }\n\n            let feature;\n            try {\n                feature = this._loadFeature(name);\n            } catch (err) {\n                //ignore the first trial\n                //this.log('warn', err.message, { err });\n            }\n\n            if (feature && feature.stage === Feature.CONF) {\n                configStageFeatures.push([feature, featureOptions]);\n                delete this.config[name];\n            }\n        });\n\n        if (configStageFeatures.length > 0) {\n            await this._loadFeatureGroup_(configStageFeatures, Feature.CONF);\n\n            //reload all features if any type of configuration feature exists\n            return this._loadFeatures_();\n        }\n\n        // if no logger in config, use console logger\n        this.flushLogCache();\n\n        await this.emit_('configFinalized', this.config);\n\n        if (this.options.logLevel === 'debug' || this.options.logLevel === 'verbose') {\n            this.log('verbose', 'Finalized config:', this.config);\n        }\n\n        let featureGroups = {\n            [Feature.INIT]: [],\n            [Feature.SERVICE]: [],\n            [Feature.PLUGIN]: [],\n            [Feature.FINAL]: [],\n        };\n\n        // load features\n        _.each(this.config, (featureOptions, name) => {\n            if (this.options.allowedFeatures && this.options.allowedFeatures.indexOf(name) === -1) {\n                //skip disabled features\n                return;\n            }\n\n            let feature = this._loadFeature(name);\n\n            if (!(feature.stage in featureGroups)) {\n                throw new Error(`Invalid feature stage. Feature: ${name}, type: ${feature.stage}`);\n            }\n\n            featureGroups[feature.stage].push([feature, featureOptions]);\n        });\n\n        return eachAsync_(featureGroups, (group, stage) => this._loadFeatureGroup_(group, stage));\n    }\n\n    async _loadFeatureGroup_(featureGroup, groupStage) {\n        featureGroup = this._sortFeatures(featureGroup);\n\n        await this.emit_('before:' + groupStage);\n        this.log('verbose', `Loading \"${groupStage}\" feature group ...`);\n\n        await eachAsync_(featureGroup, async ([feature, options]) => {\n            const { name, depends } = feature;\n            await this.emit_('before:load:' + name);\n            this.log('verbose', `Loading feature \"${name}\" ...`);\n\n            depends && this._dependsOn(depends, name);\n\n            await feature.load_(this, options, name);\n            this.features[name].enabled = true;\n            this.log('verbose', `Feature \"${name}\" loaded. [OK]`);\n\n            await this.emit_('after:load:' + name);\n        });\n        this.log('verbose', `Finished loading \"${groupStage}\" feature group. [OK]`);\n\n        await this.emit_('after:' + groupStage);\n    }\n\n    _dependsOn(features, fromFeature) {\n        let hasNotEnabled = _.find(_.castArray(features), (feature) => !this.enabled(feature));\n\n        if (hasNotEnabled) {\n            throw new Error(`The \"${hasNotEnabled}\" feature depended by \"${fromFeature}\" feature is not enabled.`);\n        }\n    }\n\n    /**\n     * Load a feature object by name.\n     * @private\n     * @param {string} feature\n     * @returns {object}\n     */\n    _loadFeature(feature) {\n        let featureObject = this.features[feature];\n        if (featureObject) return featureObject;\n\n        let featurePath;\n\n        if (this._featureRegistry.hasOwnProperty(feature)) {\n            //load by registry entry\n            let loadOption = this._featureRegistry[feature];\n\n            if (Array.isArray(loadOption)) {\n                if (loadOption.length === 0) {\n                    throw new Error(`Invalid registry value for feature \"${feature}\".`);\n                }\n\n                featurePath = loadOption[0];\n                featureObject = this.tryRequire(featurePath);\n\n                if (loadOption.length > 1) {\n                    //one module may contains more than one feature\n                    featureObject = _.get(featureObject, loadOption[1]);\n                }\n            } else {\n                featurePath = loadOption;\n                featureObject = this.tryRequire(featurePath);\n            }\n        } else {\n            //load by fallback paths\n            let searchingPath = this._featureRegistry['*'];\n\n            //reverse fallback stack\n            let found = _.findLast(searchingPath, (p) =>\n                FILE_EXT.find((ext) => {\n                    featurePath = path.join(p, feature + ext);\n                    return fs.existsSync(featurePath);\n                })\n            );\n\n            if (!found) {\n                throw new InvalidConfiguration(`Don't know where to load feature \"${feature}\".`, this, {\n                    feature,\n                    searchingPath,\n                });\n            }\n\n            featureObject = this.tryRequire(featurePath);\n        }\n\n        if (!Feature.validate(featureObject)) {\n            throw new Error(`Invalid feature object loaded from \"${featurePath}\".`);\n        }\n\n        featureObject = typeof featureObject === 'function' ? featureObject(this) : featureObject;\n        featureObject.name = feature;\n        this.features[feature] = featureObject;\n        return featureObject;\n    }\n}\n\nexport default ServiceContainer;\n"],"names":["FILE_EXT","configOverrider","defConf","envConf","serviceGroup","defServiceGroup","_def","envServiceGroup","_env","_","each","servicesMap","serviceName","ret","isEmpty","ServiceContainer","AsyncEmitter","start_","log","name","emit_","_featureRegistry","_getFeatureFallbackPath","features","services","options","loadConfigFromOptions","config","configLoader","disableEnvAwareConfig","ConfigLoader","JsonConfigProvider","path","join","configPath","configName","createEnvAwareJsonLoader","env","loadConfig_","_loadFeatures_","started","stop_","allOff","configVariables","_getConfigVariables","load_","toAbsolutePath","args","length","workingPath","resolve","tryRequire","pkgName","local","obj","require","_tryRequire","esmCheck","registerService","serviceObject","override","Error","hasService","getService","enabled","feature","addFeatureRegistry","registry","hasOwnProperty","pushIntoBucket","Object","assign","omit","logException","level","error","summary","message","pick","featureConfig","typeInfo","sanitize","category","Types","type","undefined","err","InvalidConfiguration","processInfo","process","arch","argv","cwd","pid","platform","app","__dirname","featuresPath","_sortFeatures","topoSort","TopoSort","forEach","depends","groups","arrayToObject","keys","sort","sorted","key","push","flushLogCache","runnable","logger","setLogLevel","logLevel","logging","makeLogger","consoleLogger","_logCache","configStageFeatures","featureOptions","allowedFeatures","indexOf","_loadFeature","stage","Feature","CONF","_loadFeatureGroup_","featureGroups","INIT","SERVICE","PLUGIN","FINAL","eachAsync_","group","featureGroup","groupStage","_dependsOn","fromFeature","hasNotEnabled","find","castArray","featureObject","featurePath","loadOption","Array","isArray","get","searchingPath","found","findLast","p","ext","fs","existsSync","validate","constructor","logError","logErrorAsWarning","defaultOpts"],"mappings":"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"}