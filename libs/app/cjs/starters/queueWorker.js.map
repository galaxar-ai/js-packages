{"version":3,"sources":["../../lib/starters/queueWorker.js"],"sourcesContent":["\"use strict\";\n\nconst startWorker = require('./worker');\n\n/**\n * Start a message queue worker.\n * @param {Function} worker  \n * @param {*} queueService \n * @param {*} queueName  \n * @param {object} options \n */\nasync function startQueueWorker(worker, queueService, queueName, options) {    \n    let { workerName, ...workerOptions } = options;\n\n    if (!workerName) {\n        workerName = queueName + 'Worker';\n    }  \n\n    return startWorker(async (app) => {\n        let messageQueue = app.getService(queueService);\n\n        app.log('info', `A queue worker is started and waiting for message on queue \"${queueName}\" ...`);\n\n        await messageQueue.workerConsume_(queueName, (channel, msg) => {            \n            let info = msg && msg.content;\n\n            try {\n                info = info && JSON.parse(info.toString());\n            } catch (error) {\n                app.log('error', 'The incoming message is not a valid JSON string.');\n                channel.ack(msg);  \n                return;\n            }\n\n            if (info && info.$mock) {\n                app.log('info', 'A mock message is received.\\nMessage: ' + raw);\n                channel.ack(msg);  \n                return;\n            }\n\n            worker(app, info).then(shouldAck => {\n                if (shouldAck) {                    \n                    channel.ack(msg);  \n                } else {\n                    channel.nack(msg);  \n                }                    \n            }).catch(error => {\n                app.log('error', error.message, { ...error.info, stack: error.stack });\n\n                if (error.needRetry) {\n                    channel.nack(msg);  \n                } else {\n                    channel.ack(msg);\n                } \n            });            \n        });\n\n    }, { ...workerOptions, workerName, dontStop: true });\n}\n\nmodule.exports = startQueueWorker;"],"names":["startWorker","require","startQueueWorker","worker","queueService","queueName","options","workerName","workerOptions","app","messageQueue","getService","log","workerConsume_","channel","msg","info","content","JSON","parse","toString","error","ack","$mock","raw","then","shouldAck","nack","catch","message","stack","needRetry","dontStop","module","exports"],"mappings":"AAAA,aAEA,MAAMA,YAAcC,QAAQ,YAS5B,eAAeC,iBAAiBC,MAAM,CAAEC,YAAY,CAAEC,SAAS,CAAEC,OAAO,CAAE,CACtE,GAAI,CAAEC,UAAU,CAAE,GAAGC,cAAe,CAAGF,QAEvC,GAAI,CAACC,WAAY,CACbA,WAAaF,UAAY,QAC7B,CAAC,AAED,OAAOL,YAAY,MAAOS,KAAQ,CAC9B,IAAIC,aAAeD,IAAIE,UAAU,CAACP,cAElCK,IAAIG,GAAG,CAAC,OAAQ,CAAC,4DAA4D,EAAEP,UAAU,KAAK,CAAC,CAE/F,OAAMK,aAAaG,cAAc,CAACR,UAAW,CAACS,QAASC,MAAQ,CAC3D,IAAIC,KAAOD,KAAOA,IAAIE,OAAO,CAE7B,GAAI,CACAD,KAAOA,MAAQE,KAAKC,KAAK,CAACH,KAAKI,QAAQ,GAC3C,CAAE,MAAOC,MAAO,CACZZ,IAAIG,GAAG,CAAC,QAAS,oDACjBE,QAAQQ,GAAG,CAACP,KACZ,MACJ,CAEA,GAAIC,MAAQA,KAAKO,KAAK,CAAE,CACpBd,IAAIG,GAAG,CAAC,OAAQ,yCAA2CY,KAC3DV,QAAQQ,GAAG,CAACP,KACZ,MACJ,CAAC,AAEDZ,OAAOM,IAAKO,MAAMS,IAAI,CAACC,WAAa,CAChC,GAAIA,UAAW,CACXZ,QAAQQ,GAAG,CAACP,IAChB,KAAO,CACHD,QAAQa,IAAI,CAACZ,IACjB,CAAC,AACL,GAAGa,KAAK,CAACP,OAAS,CACdZ,IAAIG,GAAG,CAAC,QAASS,MAAMQ,OAAO,CAAE,CAAE,GAAGR,MAAML,IAAI,CAAEc,MAAOT,MAAMS,KAAK,AAAC,GAEpE,GAAIT,MAAMU,SAAS,CAAE,CACjBjB,QAAQa,IAAI,CAACZ,IACjB,KAAO,CACHD,QAAQQ,GAAG,CAACP,IAChB,CAAC,AACL,EACJ,EAEJ,EAAG,CAAE,GAAGP,aAAa,CAAED,WAAYyB,SAAU,IAAI,AAAC,EACtD,CAEAC,OAAOC,OAAO,CAAGhC"}